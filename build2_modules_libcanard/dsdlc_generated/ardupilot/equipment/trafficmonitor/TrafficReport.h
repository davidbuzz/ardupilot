/*
 * UAVCAN data structure definition for libcanard.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/buzz/ardupilot/libraries/AP_UAVCAN/dsdl/ardupilot/equipment/trafficmonitor/20790.TrafficReport.uavcan
 */

#ifndef __ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT
#define __ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT

#include <stdint.h>
#include "canard.h"

#ifdef __cplusplus
extern "C"
{
#endif

#include <uavcan/Timestamp.h>

/******************************* Source text **********************************
# Network-synchronized timestamp, 0 if not available. Note: not necessarily a UTC time.
uavcan.Timestamp timestamp

# icao address
uint32 icao_address

# Time since last communication in seconds
uint16 tslc

# Traffic position in lat-lon-alt. Check alt_type for altitude datum
int32 latitude_deg_1e7
int32 longitude_deg_1e7
float32 alt_m

# Traffic heading in radians.
# Course over ground if heading is unavailable. 0 if neither are available.
float16 heading

# Traffic velocity in m/s
float16[3] velocity

# Traffic squawk code
uint16 squawk

# Traffic callsign
uint8[9] callsign

# Traffic source
uint3 SOURCE_ADSB = 0
uint3 SOURCE_ADSB_UAT = 1
uint3 SOURCE_FLARM = 2
uint3 source

# Traffic type
uint5 TRAFFIC_TYPE_UNKNOWN = 0
uint5 TRAFFIC_TYPE_LIGHT = 1
uint5 TRAFFIC_TYPE_SMALL = 2
uint5 TRAFFIC_TYPE_LARGE = 3
uint5 TRAFFIC_TYPE_HIGH_VORTEX_LARGE = 4
uint5 TRAFFIC_TYPE_HEAVY = 5
uint5 TRAFFIC_TYPE_HIGHLY_MANUV = 6
uint5 TRAFFIC_TYPE_ROTOCRAFT = 7
uint5 TRAFFIC_TYPE_GLIDER = 9
uint5 TRAFFIC_TYPE_LIGHTER_THAN_AIR = 10
uint5 TRAFFIC_TYPE_PARACHUTE = 11
uint5 TRAFFIC_TYPE_ULTRA_LIGHT = 12
uint5 TRAFFIC_TYPE_UAV = 14
uint5 TRAFFIC_TYPE_SPACE = 15
uint5 TRAFFIC_TYPE_EMERGENCY_SURFACE = 17
uint5 TRAFFIC_TYPE_SERVICE_SURFACE = 18
uint5 TRAFFIC_TYPE_POINT_OBSTACLE = 19
uint5 traffic_type

# Altitude type
uint7 ALT_TYPE_ALT_UNKNOWN = 0
uint7 ALT_TYPE_PRESSURE_AMSL = 1
uint7 ALT_TYPE_WGS84 = 2
uint7 alt_type

# Validity flags
bool lat_lon_valid
bool heading_valid
bool velocity_valid
bool callsign_valid
bool ident_valid
bool simulated_report
bool vertical_velocity_valid
bool baro_valid
******************************************************************************/

/********************* DSDL signature source definition ***********************
ardupilot.equipment.trafficmonitor.TrafficReport
uavcan.Timestamp timestamp
saturated uint32 icao_address
saturated uint16 tslc
saturated int32 latitude_deg_1e7
saturated int32 longitude_deg_1e7
saturated float32 alt_m
saturated float16 heading
saturated float16[3] velocity
saturated uint16 squawk
saturated uint8[9] callsign
saturated uint3 source
saturated uint5 traffic_type
saturated uint7 alt_type
saturated bool lat_lon_valid
saturated bool heading_valid
saturated bool velocity_valid
saturated bool callsign_valid
saturated bool ident_valid
saturated bool simulated_report
saturated bool vertical_velocity_valid
saturated bool baro_valid
******************************************************************************/

#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ID 20790
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_NAME "ardupilot.equipment.trafficmonitor.TrafficReport"
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SIGNATURE (0x68E45DB60B6981F8ULL)

#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_MAX_SIZE ((375 + 7)/8)

// Constants
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SOURCE_ADSB          0 // 0
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SOURCE_ADSB_UAT          1 // 1
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SOURCE_FLARM          2 // 2
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_UNKNOWN          0 // 0
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_LIGHT          1 // 1
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_SMALL          2 // 2
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_LARGE          3 // 3
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_HIGH_VORTEX_LARGE          4 // 4
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_HEAVY          5 // 5
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_HIGHLY_MANUV          6 // 6
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_ROTOCRAFT          7 // 7
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_GLIDER          9 // 9
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_LIGHTER_THAN_AIR         10 // 10
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_PARACHUTE         11 // 11
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_ULTRA_LIGHT         12 // 12
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_UAV         14 // 14
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_SPACE         15 // 15
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_EMERGENCY_SURFACE         17 // 17
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_SERVICE_SURFACE         18 // 18
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_TRAFFIC_TYPE_POINT_OBSTACLE         19 // 19
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ALT_TYPE_ALT_UNKNOWN          0 // 0
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ALT_TYPE_PRESSURE_AMSL          1 // 1
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ALT_TYPE_WGS84          2 // 2

#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_VELOCITY_LENGTH                 3
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_CALLSIGN_LENGTH                 9

typedef struct
{
    // FieldTypes
    uavcan_Timestamp timestamp;                     //
    uint32_t   icao_address;                  // bit len 32
    uint16_t   tslc;                          // bit len 16
    int32_t    latitude_deg_1e7;              // bit len 32
    int32_t    longitude_deg_1e7;             // bit len 32
    float      alt_m;                         // float32 Saturate
    float      heading;                       // float16 Saturate
    float      velocity[3];                   // Static Array 16bit[3] max items
    uint16_t   squawk;                        // bit len 16
    uint8_t    callsign[9];                   // Static Array 8bit[9] max items
    uint8_t    source;                        // bit len 3
    uint8_t    traffic_type;                  // bit len 5
    uint8_t    alt_type;                      // bit len 7
    bool       lat_lon_valid;                 // bit len 1
    bool       heading_valid;                 // bit len 1
    bool       velocity_valid;                // bit len 1
    bool       callsign_valid;                // bit len 1
    bool       ident_valid;                   // bit len 1
    bool       simulated_report;              // bit len 1
    bool       vertical_velocity_valid;       // bit len 1
    bool       baro_valid;                    // bit len 1

} ardupilot_equipment_trafficmonitor_TrafficReport;

static inline
uint32_t ardupilot_equipment_trafficmonitor_TrafficReport_encode(ardupilot_equipment_trafficmonitor_TrafficReport* source, void* msg_buf);

static inline
int32_t ardupilot_equipment_trafficmonitor_TrafficReport_decode(const CanardRxTransfer* transfer, uint16_t payload_len, ardupilot_equipment_trafficmonitor_TrafficReport* dest, uint8_t** dyn_arr_buf);

static inline
uint32_t ardupilot_equipment_trafficmonitor_TrafficReport_encode_internal(ardupilot_equipment_trafficmonitor_TrafficReport* source, void* msg_buf, uint32_t offset, uint8_t root_item);

static inline
int32_t ardupilot_equipment_trafficmonitor_TrafficReport_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, ardupilot_equipment_trafficmonitor_TrafficReport* dest, uint8_t** dyn_arr_buf, int32_t offset);

/*
 * UAVCAN data structure definition for libcanard.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/buzz/ardupilot/libraries/AP_UAVCAN/dsdl/ardupilot/equipment/trafficmonitor/20790.TrafficReport.uavcan
 */

#ifndef CANARD_INTERNAL_SATURATE
#define CANARD_INTERNAL_SATURATE(x, max) ( ((x) > max) ? max : ( (-(x) > max) ? (-max) : (x) ) );
#endif

#ifndef CANARD_INTERNAL_SATURATE_UNSIGNED
#define CANARD_INTERNAL_SATURATE_UNSIGNED(x, max) ( ((x) >= max) ? max : (x) );
#endif

#if defined(__GNUC__)
# define CANARD_MAYBE_UNUSED(x) x __attribute__((unused))
#else
# define CANARD_MAYBE_UNUSED(x) x
#endif

/**
  * @brief ardupilot_equipment_trafficmonitor_TrafficReport_encode_internal
  * @param source : pointer to source data struct
  * @param msg_buf: pointer to msg storage
  * @param offset: bit offset to msg storage
  * @param root_item: for detecting if TAO should be used
  * @retval returns offset
  */
uint32_t ardupilot_equipment_trafficmonitor_TrafficReport_encode_internal(ardupilot_equipment_trafficmonitor_TrafficReport* source,
  void* msg_buf,
  uint32_t offset,
  uint8_t CANARD_MAYBE_UNUSED(root_item))
{
    uint32_t c = 0;
#ifndef CANARD_USE_FLOAT16_CAST
    uint16_t tmp_float = 0;
#else
    CANARD_USE_FLOAT16_CAST tmp_float = 0;
#endif

    // Compound
    offset = uavcan_Timestamp_encode_internal(&source->timestamp, msg_buf, offset, 0);
    canardEncodeScalar(msg_buf, offset, 32, (void*)&source->icao_address); // 4294967295
    offset += 32;

    canardEncodeScalar(msg_buf, offset, 16, (void*)&source->tslc); // 65535
    offset += 16;

    canardEncodeScalar(msg_buf, offset, 32, (void*)&source->latitude_deg_1e7); // 2147483647
    offset += 32;

    canardEncodeScalar(msg_buf, offset, 32, (void*)&source->longitude_deg_1e7); // 2147483647
    offset += 32;

    canardEncodeScalar(msg_buf, offset, 32, (void*)&source->alt_m); // 2147483647
    offset += 32;

    // float16 special handling
#ifndef CANARD_USE_FLOAT16_CAST
    tmp_float = canardConvertNativeFloatToFloat16(source->heading);
#else
    tmp_float = (CANARD_USE_FLOAT16_CAST)source->heading;
#endif
    canardEncodeScalar(msg_buf, offset, 16, (void*)&tmp_float); // 32767
    offset += 16;
    // Static array (velocity)
    for (c = 0; c < 3; c++)
    {
        canardEncodeScalar(msg_buf, offset, 16, (void*)(source->velocity + c)); // 32767
        offset += 16;
    }

    canardEncodeScalar(msg_buf, offset, 16, (void*)&source->squawk); // 65535
    offset += 16;

    // Static array (callsign)
    for (c = 0; c < 9; c++)
    {
        canardEncodeScalar(msg_buf, offset, 8, (void*)(source->callsign + c)); // 255
        offset += 8;
    }

    source->source = CANARD_INTERNAL_SATURATE_UNSIGNED(source->source, 7)
    canardEncodeScalar(msg_buf, offset, 3, (void*)&source->source); // 7
    offset += 3;

    source->traffic_type = CANARD_INTERNAL_SATURATE_UNSIGNED(source->traffic_type, 31)
    canardEncodeScalar(msg_buf, offset, 5, (void*)&source->traffic_type); // 31
    offset += 5;

    source->alt_type = CANARD_INTERNAL_SATURATE_UNSIGNED(source->alt_type, 127)
    canardEncodeScalar(msg_buf, offset, 7, (void*)&source->alt_type); // 127
    offset += 7;

    source->lat_lon_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->lat_lon_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->lat_lon_valid); // 1
    offset += 1;

    source->heading_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->heading_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->heading_valid); // 1
    offset += 1;

    source->velocity_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->velocity_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->velocity_valid); // 1
    offset += 1;

    source->callsign_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->callsign_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->callsign_valid); // 1
    offset += 1;

    source->ident_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->ident_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->ident_valid); // 1
    offset += 1;

    source->simulated_report = CANARD_INTERNAL_SATURATE_UNSIGNED(source->simulated_report, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->simulated_report); // 1
    offset += 1;

    source->vertical_velocity_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->vertical_velocity_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->vertical_velocity_valid); // 1
    offset += 1;

    source->baro_valid = CANARD_INTERNAL_SATURATE_UNSIGNED(source->baro_valid, 1)
    canardEncodeScalar(msg_buf, offset, 1, (void*)&source->baro_valid); // 1
    offset += 1;

    return offset;
}

/**
  * @brief ardupilot_equipment_trafficmonitor_TrafficReport_encode
  * @param source : Pointer to source data struct
  * @param msg_buf: Pointer to msg storage
  * @retval returns message length as bytes
  */
uint32_t ardupilot_equipment_trafficmonitor_TrafficReport_encode(ardupilot_equipment_trafficmonitor_TrafficReport* source, void* msg_buf)
{
    uint32_t offset = 0;

    offset = ardupilot_equipment_trafficmonitor_TrafficReport_encode_internal(source, msg_buf, offset, 1);

    return (offset + 7 ) / 8;
}

/**
  * @brief ardupilot_equipment_trafficmonitor_TrafficReport_decode_internal
  * @param transfer: Pointer to CanardRxTransfer transfer
  * @param payload_len: Payload message length
  * @param dest: Pointer to destination struct
  * @param dyn_arr_buf: NULL or Pointer to memory storage to be used for dynamic arrays
  *                     ardupilot_equipment_trafficmonitor_TrafficReport dyn memory will point to dyn_arr_buf memory.
  *                     NULL will ignore dynamic arrays decoding.
  * @param offset: Call with 0, bit offset to msg storage
  * @retval offset or ERROR value if < 0
  */
int32_t ardupilot_equipment_trafficmonitor_TrafficReport_decode_internal(
  const CanardRxTransfer* transfer,
  uint16_t CANARD_MAYBE_UNUSED(payload_len),
  ardupilot_equipment_trafficmonitor_TrafficReport* dest,
  uint8_t** CANARD_MAYBE_UNUSED(dyn_arr_buf),
  int32_t offset)
{
    int32_t ret = 0;
    uint32_t c = 0;
#ifndef CANARD_USE_FLOAT16_CAST
    uint16_t tmp_float = 0;
#else
    CANARD_USE_FLOAT16_CAST tmp_float = 0;
#endif

    // Compound
    offset = uavcan_Timestamp_decode_internal(transfer, payload_len, &dest->timestamp, dyn_arr_buf, offset);
    if (offset < 0)
    {
        ret = offset;
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 32, false, (void*)&dest->icao_address);
    if (ret != 32)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 32;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 16, false, (void*)&dest->tslc);
    if (ret != 16)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 16;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 32, true, (void*)&dest->latitude_deg_1e7);
    if (ret != 32)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 32;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 32, true, (void*)&dest->longitude_deg_1e7);
    if (ret != 32)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 32;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 32, false, (void*)&dest->alt_m);
    if (ret != 32)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 32;

    // float16 special handling
    ret = canardDecodeScalar(transfer, (uint32_t)offset, 16, false, (void*)&tmp_float);

    if (ret != 16)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
#ifndef CANARD_USE_FLOAT16_CAST
    dest->heading = canardConvertFloat16ToNativeFloat(tmp_float);
#else
    dest->heading = (float)tmp_float;
#endif
    offset += 16;

    // Static array (velocity)
    for (c = 0; c < 3; c++)
    {
        ret = canardDecodeScalar(transfer, (uint32_t)offset, 16, false, (void*)(dest->velocity + c));
        if (ret != 16)
        {
            goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
        }
        offset += 16;
    }

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 16, false, (void*)&dest->squawk);
    if (ret != 16)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 16;

    // Static array (callsign)
    for (c = 0; c < 9; c++)
    {
        ret = canardDecodeScalar(transfer, (uint32_t)offset, 8, false, (void*)(dest->callsign + c));
        if (ret != 8)
        {
            goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
        }
        offset += 8;
    }

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 3, false, (void*)&dest->source);
    if (ret != 3)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 3;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 5, false, (void*)&dest->traffic_type);
    if (ret != 5)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 5;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 7, false, (void*)&dest->alt_type);
    if (ret != 7)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 7;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->lat_lon_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->heading_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->velocity_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->callsign_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->ident_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->simulated_report);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->vertical_velocity_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;

    ret = canardDecodeScalar(transfer, (uint32_t)offset, 1, false, (void*)&dest->baro_valid);
    if (ret != 1)
    {
        goto ardupilot_equipment_trafficmonitor_TrafficReport_error_exit;
    }
    offset += 1;
    return offset;

ardupilot_equipment_trafficmonitor_TrafficReport_error_exit:
    if (ret < 0)
    {
        return ret;
    }
    else
    {
        return -CANARD_ERROR_INTERNAL;
    }
}

/**
  * @brief ardupilot_equipment_trafficmonitor_TrafficReport_decode
  * @param transfer: Pointer to CanardRxTransfer transfer
  * @param payload_len: Payload message length
  * @param dest: Pointer to destination struct
  * @param dyn_arr_buf: NULL or Pointer to memory storage to be used for dynamic arrays
  *                     ardupilot_equipment_trafficmonitor_TrafficReport dyn memory will point to dyn_arr_buf memory.
  *                     NULL will ignore dynamic arrays decoding.
  * @retval offset or ERROR value if < 0
  */
int32_t ardupilot_equipment_trafficmonitor_TrafficReport_decode(const CanardRxTransfer* transfer,
  uint16_t payload_len,
  ardupilot_equipment_trafficmonitor_TrafficReport* dest,
  uint8_t** dyn_arr_buf)
{
    const int32_t offset = 0;
    int32_t ret = 0;

    // Clear the destination struct
    for (uint32_t c = 0; c < sizeof(ardupilot_equipment_trafficmonitor_TrafficReport); c++)
    {
        ((uint8_t*)dest)[c] = 0x00;
    }

    ret = ardupilot_equipment_trafficmonitor_TrafficReport_decode_internal(transfer, payload_len, dest, dyn_arr_buf, offset);

    return ret;
}

#ifdef __cplusplus
} // extern "C"
#endif
#endif // __ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT